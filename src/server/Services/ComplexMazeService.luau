-- Kanata Maze è¤‡é›‘è¿·è·¯ç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹
local ComplexMazeService = {}

local workspace = game:GetService("Workspace")

-- è¿·è·¯ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒ•ãƒ©ã‚°
local mazeSystemInitialized = false

-- è¿·è·¯ã®è¨­å®šï¼ˆConstants.luauã‹ã‚‰ï¼‰
local MAZE_WIDTH = 186  -- è¿·è·¯ã®å¹…ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
local MAZE_HEIGHT = 150 -- è¿·è·¯ã®å¥¥è¡Œãï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
local WALL_SIZE = 6     -- å„å£ã‚»ãƒ«ã®ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰
local WALL_HEIGHT = 40  -- å£ã®é«˜ã•ï¼ˆã‚¹ã‚¿ãƒƒãƒ‰ï¼‰

-- è¿·è·¯ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºï¼ˆ31x25 = 186x150ã‚¹ã‚¿ãƒƒãƒ‰ã«å¯¾å¿œï¼‰
local GRID_WIDTH = math.floor(MAZE_WIDTH / WALL_SIZE)   -- 31
local GRID_HEIGHT = math.floor(MAZE_HEIGHT / WALL_SIZE) -- 25

-- å£ä½œæˆé–¢æ•°
local function createWall(position, size, name, parent)
    local wall = Instance.new("Part")
    wall.Name = name
    wall.Size = size
    wall.Position = position
    wall.Anchored = true
    wall.Material = Enum.Material.Brick
    wall.BrickColor = BrickColor.new("Dark stone grey")
    wall.Parent = parent
    return wall
end

-- è¤‡é›‘è¿·è·¯ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæ”¹è‰¯ç‰ˆ Recursive Backtrackingï¼‰
local function generateComplexMaze()
    -- 1 = å£, 0 = é€šè·¯
    local maze = {}
    
    -- åˆæœŸåŒ–ï¼šå…¨ã¦å£
    for y = 1, GRID_HEIGHT do
        maze[y] = {}
        for x = 1, GRID_WIDTH do
            maze[y][x] = 1
        end
    end
    
    -- æ–¹å‘å®šç¾©ï¼ˆä¸Šã€å³ã€ä¸‹ã€å·¦ï¼‰- 1ã‚»ãƒ«ãšã¤ç§»å‹•
    local directions = {
        {0, -1}, {1, 0}, {0, 1}, {-1, 0}
    }
    
    -- ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆRecursive Backtrackingç”¨ï¼‰
    local stack = {}
    
    -- é–‹å§‹ç‚¹è¨ˆç®—ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆä»˜è¿‘ã‹ã‚‰é–‹å§‹ï¼‰
    local centerX = math.floor(GRID_WIDTH / 2) + 1
    local startGateGridZ = math.floor(((-73) - (-(MAZE_HEIGHT/2))) / WALL_SIZE) + 1
    
    -- é–‹å§‹ç‚¹ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆä»˜è¿‘ã«è¨­å®šï¼ˆå®‰å…¨ãªç¯„å›²å†…ï¼‰
    local startX = centerX
    local startY = math.max(2, math.min(GRID_HEIGHT-1, startGateGridZ))
    
    maze[startY][startX] = 0
    table.insert(stack, {startX, startY})
    
    -- Recursive Backtracking ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    while #stack > 0 do
        local current = stack[#stack]
        local x, y = current[1], current[2]
        
        -- éš£æ¥ã™ã‚‹æœªè¨ªå•ã®ã‚»ãƒ«ã‚’æ¢ã™
        local neighbors = {}
        for _, dir in ipairs(directions) do
            local nx, ny = x + dir[1], y + dir[2]
            if nx >= 2 and nx <= GRID_WIDTH-1 and ny >= 2 and ny <= GRID_HEIGHT-1 then
                if maze[ny][nx] == 1 then
                    table.insert(neighbors, {nx, ny, dir})
                end
            end
        end
        
        if #neighbors > 0 then
            -- ãƒ©ãƒ³ãƒ€ãƒ ã«éš£æ¥ã‚»ãƒ«ã‚’é¸æŠ
            local next = neighbors[math.random(#neighbors)]
            local nx, ny, dir = next[1], next[2], next[3]
            
            -- éš£æ¥ã‚»ãƒ«ã‚’é€šè·¯ã«ã™ã‚‹
            maze[ny][nx] = 0
            
            table.insert(stack, {nx, ny})
        else
            -- è¡Œãæ­¢ã¾ã‚Š - ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯
            table.remove(stack)
        end
    end
    
    -- è¿½åŠ ã®é€šè·¯ã‚’ä½œæˆï¼ˆé€£çµæ€§ã‚’å‘ä¸Šï¼‰
    for attempts = 1, math.floor(GRID_WIDTH * GRID_HEIGHT * 0.1) do
        local x = math.random(2, GRID_WIDTH-1)
        local y = math.random(2, GRID_HEIGHT-1)
        
        if maze[y][x] == 1 then
            -- å‘¨è¾ºã«é€šè·¯ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            local hasPathNeighbor = false
            for _, dir in ipairs(directions) do
                local nx, ny = x + dir[1], y + dir[2]
                if nx >= 1 and nx <= GRID_WIDTH and ny >= 1 and ny <= GRID_HEIGHT then
                    if maze[ny] and maze[ny][nx] == 0 then
                        hasPathNeighbor = true
                        break
                    end
                end
            end
            
            -- éš£ã«é€šè·¯ãŒã‚ã‚Œã°ã€ã“ã®å£ã‚’é€šè·¯ã«å¤‰æ›ï¼ˆ30%ã®ç¢ºç‡ï¼‰
            if hasPathNeighbor and math.random() < 0.3 then
                maze[y][x] = 0
            end
        end
    end
    
    -- ã‚¹ã‚¿ãƒ¼ãƒˆã¨ã‚´ãƒ¼ãƒ«ã®å…¥å£ç¢ºä¿
    local centerX = math.floor(GRID_WIDTH / 2) + 1
    
    -- ã‚¹ã‚¿ãƒ¼ãƒˆå…¥å£ã®åº§æ¨™è¨ˆç®—ï¼ˆz=-73ã®ä½ç½®ï¼‰
    -- è¿·è·¯ã®ç¯„å›²ã¯ z=-75 ã‹ã‚‰ z=+75 ãªã®ã§ã€z=-73ã¯è¿·è·¯ã®ä¸‹ç«¯ä»˜è¿‘
    local startGateGridZ = math.floor(((-73) - (-(MAZE_HEIGHT/2))) / WALL_SIZE) + 1
    
    -- ã‚´ãƒ¼ãƒ«å…¥å£ã®åº§æ¨™è¨ˆç®—ï¼ˆz=73ã®ä½ç½®ï¼‰  
    -- z=73ã¯è¿·è·¯ã®ä¸Šç«¯ä»˜è¿‘
    local goalGateGridZ = math.floor(((73) - (-(MAZE_HEIGHT/2))) / WALL_SIZE) + 1
    
    -- ã‚¹ã‚¿ãƒ¼ãƒˆå…¥å£ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆ z=-73 ä»˜è¿‘ï¼‰- åºƒç¯„å›²ã‚¯ãƒªã‚¢
    if startGateGridZ >= 1 and startGateGridZ <= GRID_HEIGHT then
        -- ä¸­å¤®ã®é€šè·¯
        maze[startGateGridZ][centerX] = 0
        -- å‰å¾Œã®é€šè·¯ï¼ˆ3ãƒã‚¹åˆ†ç¢ºä¿ï¼‰
        for offset = -2, 2 do
            local targetY = startGateGridZ + offset
            if targetY >= 1 and targetY <= GRID_HEIGHT then
                maze[targetY][centerX] = 0
                -- å·¦å³ã«ã‚‚å°‘ã—é€šè·¯ã‚’ä½œæˆï¼ˆTå­—è·¯ã‚’ä½œã‚‹ï¼‰
                if centerX > 1 then maze[targetY][centerX-1] = 0 end
                if centerX < GRID_WIDTH then maze[targetY][centerX+1] = 0 end
            end
        end
    end
    
    -- ã‚´ãƒ¼ãƒ«å…¥å£ï¼ˆã‚´ãƒ¼ãƒ«ã‚²ãƒ¼ãƒˆ z=73 ä»˜è¿‘ï¼‰- åºƒç¯„å›²ã‚¯ãƒªã‚¢
    if goalGateGridZ >= 1 and goalGateGridZ <= GRID_HEIGHT then
        -- ä¸­å¤®ã®é€šè·¯
        maze[goalGateGridZ][centerX] = 0
        -- å‰å¾Œã®é€šè·¯ï¼ˆ3ãƒã‚¹åˆ†ç¢ºä¿ï¼‰
        for offset = -2, 2 do
            local targetY = goalGateGridZ + offset
            if targetY >= 1 and targetY <= GRID_HEIGHT then
                maze[targetY][centerX] = 0
                -- å·¦å³ã«ã‚‚å°‘ã—é€šè·¯ã‚’ä½œæˆï¼ˆTå­—è·¯ã‚’ä½œã‚‹ï¼‰
                if centerX > 1 then maze[targetY][centerX-1] = 0 end
                if centerX < GRID_WIDTH then maze[targetY][centerX+1] = 0 end
            end
        end
    end
    
    -- ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    print("ğŸšª å…¥å£åº§æ¨™è¨ˆç®—:")
    print("  ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆ z=-73 â†’ ã‚°ãƒªãƒƒãƒ‰è¡Œ: " .. (startGateGridZ or "ç¯„å›²å¤–"))
    print("  ã‚´ãƒ¼ãƒ«ã‚²ãƒ¼ãƒˆ z=73 â†’ ã‚°ãƒªãƒƒãƒ‰è¡Œ: " .. (goalGateGridZ or "ç¯„å›²å¤–"))
    print("  ä¸­å¤®åˆ—: " .. centerX)
    
    -- ç¢ºå®Ÿãªä¸­å¤®é€šè·¯ã®ä½œæˆï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆã‹ã‚‰ã‚´ãƒ¼ãƒ«ã¾ã§ï¼‰
    print("ğŸ›¤ï¸ ä¸­å¤®åŸºå¹¹é€šè·¯ã‚’ä½œæˆä¸­...")
    for y = math.min(startGateGridZ, goalGateGridZ), math.max(startGateGridZ, goalGateGridZ) do
        if y >= 1 and y <= GRID_HEIGHT then
            maze[y][centerX] = 0
            -- åŸºå¹¹é€šè·¯ã‹ã‚‰å·¦å³ã«åˆ†å²ã‚‚ä½œæˆ
            if centerX > 2 and math.random() < 0.4 then
                maze[y][centerX-1] = 0
            end
            if centerX < GRID_WIDTH-1 and math.random() < 0.4 then
                maze[y][centerX+1] = 0
            end
        end
    end
    
    -- è¤‡é›‘åŒ–ï¼šãƒ©ãƒ³ãƒ€ãƒ ã«è¿½åŠ ã®é€šè·¯ã‚’ä½œæˆï¼ˆé›£æ˜“åº¦èª¿æ•´ï¼‰
    local complexityFactor = 0.08 -- 8%ã®å£ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é™¤å»ï¼ˆé€£çµæ€§å‘ä¸Šã®ãŸã‚å¢—åŠ ï¼‰
    for y = 2, GRID_HEIGHT-1 do
        for x = 2, GRID_WIDTH-1 do
            if maze[y][x] == 1 and math.random() < complexityFactor then
                maze[y][x] = 0
            end
        end
    end
    
    -- è¡Œãæ­¢ã¾ã‚Šå‰Šæ¸›ï¼šä¸€éƒ¨ã®è¡Œãæ­¢ã¾ã‚Šã«è¿½åŠ å‡ºå£ã‚’ä½œæˆ
    for y = 2, GRID_HEIGHT-1 do
        for x = 2, GRID_WIDTH-1 do
            if maze[y][x] == 0 then
                local neighbors = 0
                for _, dir in ipairs(directions) do
                    local nx, ny = x + dir[1]/2, y + dir[2]/2
                    if nx >= 1 and nx <= GRID_WIDTH and ny >= 1 and ny <= GRID_HEIGHT then
                        if maze[ny] and maze[ny][nx] == 0 then
                            neighbors = neighbors + 1
                        end
                    end
                end
                
                -- è¡Œãæ­¢ã¾ã‚Šï¼ˆéš£æ¥é€šè·¯ãŒ1ã¤ã®ã¿ï¼‰ã«30%ã®ç¢ºç‡ã§è¿½åŠ å‡ºå£
                if neighbors == 1 and math.random() < 0.3 then
                    local validDirs = {}
                    for _, dir in ipairs(directions) do
                        local nx, ny = x + dir[1]/2, y + dir[2]/2
                        if nx >= 2 and nx <= GRID_WIDTH-1 and ny >= 2 and ny <= GRID_HEIGHT-1 then
                            if maze[ny] and maze[ny][nx] == 1 then
                                table.insert(validDirs, {nx, ny})
                            end
                        end
                    end
                    
                    if #validDirs > 0 then
                        local target = validDirs[math.random(#validDirs)]
                        maze[target[2]][target[1]] = 0
                    end
                end
            end
        end
    end
    
    -- çµ±è¨ˆæƒ…å ±ã®è¨ˆç®—
    local totalCells = GRID_WIDTH * GRID_HEIGHT
    local pathCells = 0
    local wallCells = 0
    
    for y = 1, GRID_HEIGHT do
        for x = 1, GRID_WIDTH do
            if maze[y][x] == 0 then
                pathCells = pathCells + 1
            else
                wallCells = wallCells + 1
            end
        end
    end
    
    local pathPercentage = math.floor((pathCells / totalCells) * 100)
    
    print("ğŸ“Š è¿·è·¯ç”Ÿæˆçµ±è¨ˆ:")
    print("  - ç·ã‚»ãƒ«æ•°: " .. totalCells)
    print("  - é€šè·¯ã‚»ãƒ«: " .. pathCells .. " (" .. pathPercentage .. "%)")
    print("  - å£ã‚»ãƒ«: " .. wallCells .. " (" .. (100-pathPercentage) .. "%)")
    
    return maze
end

-- è¤‡é›‘è¿·è·¯ã®æ§‹ç¯‰
local function buildComplexMaze(mazeGame)
    print("ğŸ—ï¸ è¤‡é›‘è¿·è·¯ç”Ÿæˆä¸­...")
    
    -- æ—¢å­˜ã®è¿·è·¯å£ã‚’å‰Šé™¤
    local existingWalls = mazeGame:FindFirstChild("Walls")
    if existingWalls then
        for _, wall in ipairs(existingWalls:GetChildren()) do
            if wall.Name:find("MazeWall") then
                wall:Destroy()
            end
        end
    else
        existingWalls = Instance.new("Folder")
        existingWalls.Name = "Walls"
        existingWalls.Parent = mazeGame
    end
    
    -- è¿·è·¯ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
    local mazePattern = generateComplexMaze()
    
    -- é‡è¦ãªåº§æ¨™è¨ˆç®—
    local startGateZ = -73  -- ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆã®Zåº§æ¨™
    local goalGateZ = 73    -- ã‚´ãƒ¼ãƒ«ã‚²ãƒ¼ãƒˆã®Zåº§æ¨™
    local mazeStartZ = -75  -- è¿·è·¯ã®é–‹å§‹Zåº§æ¨™
    local mazeEndZ = 75     -- è¿·è·¯ã®çµ‚äº†Zåº§æ¨™
    
    -- è¿·è·¯ã®å£ã‚’é…ç½®ï¼ˆãŸã ã—ã€ã‚²ãƒ¼ãƒˆä»˜è¿‘ã¯ç‰¹åˆ¥å‡¦ç†ï¼‰
    local wallCount = 0
    for y = 1, GRID_HEIGHT do
        for x = 1, GRID_WIDTH do
            if mazePattern[y][x] == 1 then
                -- ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ã‚’å®Ÿä¸–ç•Œåº§æ¨™ã«å¤‰æ›
                local worldX = (x - (GRID_WIDTH + 1) / 2) * WALL_SIZE
                local worldZ = (y - (GRID_HEIGHT + 1) / 2) * WALL_SIZE
                
                -- ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆä»˜è¿‘ï¼ˆz=-73å‘¨è¾ºï¼‰ã®å£ã¯ä½œã‚‰ãªã„
                local centerX = 0  -- ä¸­å¤®åˆ—
                local gateWidth = 18  -- ã‚²ãƒ¼ãƒˆå‘¨è¾ºã®é–‹å£éƒ¨ã®å¹…
                
                local isStartGateArea = math.abs(worldZ - startGateZ) <= 12 and math.abs(worldX - centerX) <= gateWidth
                local isGoalGateArea = math.abs(worldZ - goalGateZ) <= 12 and math.abs(worldX - centerX) <= gateWidth
                
                -- ã‚²ãƒ¼ãƒˆã‚¨ãƒªã‚¢ã§ãªã‘ã‚Œã°å£ã‚’ä½œæˆ
                if not isStartGateArea and not isGoalGateArea then
                    createWall(
                        Vector3.new(worldX, WALL_HEIGHT / 2, worldZ),
                        Vector3.new(WALL_SIZE, WALL_HEIGHT, WALL_SIZE),
                        "MazeWall_" .. x .. "_" .. y,
                        existingWalls
                    )
                    wallCount = wallCount + 1
                end
            end
        end
    end
    
    -- å¤–å‘¨å£ã®è¿½åŠ ï¼ˆè¿·è·¯ã‚’å®Œå…¨ã«å›²ã‚€ã€ãŸã ã—ã‚²ãƒ¼ãƒˆé–‹å£éƒ¨ã¯é™¤ãï¼‰
    local outerWallThickness = 3
    local gateOpeningWidth = 24  -- ã‚²ãƒ¼ãƒˆé–‹å£éƒ¨ã®å¹…
    
    -- ä¸Šä¸‹ã®å¤–å‘¨å£ï¼ˆã‚²ãƒ¼ãƒˆé–‹å£éƒ¨ã‚’é¿ã‘ã‚‹ï¼‰
    for x = -(MAZE_WIDTH/2 + outerWallThickness), (MAZE_WIDTH/2 + outerWallThickness), WALL_SIZE do
        -- ä¸Šå´ï¼ˆã‚´ãƒ¼ãƒ«ã‚²ãƒ¼ãƒˆå´ï¼‰- ä¸­å¤®é–‹å£éƒ¨ã‚’é¿ã‘ã‚‹
        if math.abs(x) > gateOpeningWidth / 2 then
            createWall(
                Vector3.new(x, WALL_HEIGHT / 2, -(MAZE_HEIGHT/2 + outerWallThickness)),
                Vector3.new(WALL_SIZE, WALL_HEIGHT, outerWallThickness * 2),
                "OuterWall_Top_" .. x,
                existingWalls
            )
            wallCount = wallCount + 1
        end
        
        -- ä¸‹å´ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆå´ï¼‰- ä¸­å¤®é–‹å£éƒ¨ã‚’é¿ã‘ã‚‹  
        if math.abs(x) > gateOpeningWidth / 2 then
            createWall(
                Vector3.new(x, WALL_HEIGHT / 2, (MAZE_HEIGHT/2 + outerWallThickness)),
                Vector3.new(WALL_SIZE, WALL_HEIGHT, outerWallThickness * 2),
                "OuterWall_Bottom_" .. x,
                existingWalls
            )
            wallCount = wallCount + 1
        end
    end
    
    -- å·¦å³ã®å¤–å‘¨å£ï¼ˆé€šå¸¸é€šã‚Šï¼‰
    for z = -(MAZE_HEIGHT/2), (MAZE_HEIGHT/2), WALL_SIZE do
        -- å·¦å´
        createWall(
            Vector3.new(-(MAZE_WIDTH/2 + outerWallThickness), WALL_HEIGHT / 2, z),
            Vector3.new(outerWallThickness * 2, WALL_HEIGHT, WALL_SIZE),
            "OuterWall_Left_" .. z,
            existingWalls
        )
        
        -- å³å´
        createWall(
            Vector3.new((MAZE_WIDTH/2 + outerWallThickness), WALL_HEIGHT / 2, z),
            Vector3.new(outerWallThickness * 2, WALL_HEIGHT, WALL_SIZE),
            "OuterWall_Right_" .. z,
            existingWalls
        )
        wallCount = wallCount + 2
    end
    
    print("âœ… è¤‡é›‘è¿·è·¯æ§‹ç¯‰å®Œäº†!")
    print("ğŸ“Š è¿·è·¯çµ±è¨ˆ:")
    print("  - ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º: " .. GRID_WIDTH .. "x" .. GRID_HEIGHT)
    print("  - å£ã®ç·æ•°: " .. wallCount .. " å€‹")
    print("  - è¿·è·¯ã‚µã‚¤ã‚º: " .. MAZE_WIDTH .. "x" .. MAZE_HEIGHT .. " ã‚¹ã‚¿ãƒƒãƒ‰")
    print("ğŸšª å…¥å£çŠ¶æ³:")
    print("  - ã‚¹ã‚¿ãƒ¼ãƒˆã‚²ãƒ¼ãƒˆ: z=" .. startGateZ .. " (é–‹å£éƒ¨å¹…: " .. gateOpeningWidth .. ")")
    print("  - ã‚´ãƒ¼ãƒ«ã‚²ãƒ¼ãƒˆ: z=" .. goalGateZ .. " (é–‹å£éƒ¨å¹…: " .. gateOpeningWidth .. ")")
    print("  - è¿·è·¯ç¯„å›²: z=" .. mazeStartZ .. " ã‹ã‚‰ z=" .. mazeEndZ)
    
    return wallCount
end

-- ãƒ¡ã‚¤ãƒ³åˆæœŸåŒ–é–¢æ•°
function ComplexMazeService.Initialize()
    if mazeSystemInitialized then
        return
    end
    
    print("ğŸŒŸ è¤‡é›‘è¿·è·¯ã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–ä¸­...")
    
    -- MazeGameã®å¾…æ©Ÿ
    local mazeGame = workspace:WaitForChild("MazeGame", 30)
    if not mazeGame then
        warn("âŒ MazeGameãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return
    end
    
    -- è¤‡é›‘è¿·è·¯æ§‹ç¯‰
    buildComplexMaze(mazeGame)
    
    mazeSystemInitialized = true
    print("âœ… è¤‡é›‘è¿·è·¯ã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–å®Œäº†ï¼")
end

-- ã‚µãƒ¼ãƒ“ã‚¹é–‹å§‹
function ComplexMazeService.Start()
    spawn(function()
        wait(3) -- åˆæœŸæ§‹é€ æ§‹ç¯‰å¾Œã«å®Ÿè¡Œ
        ComplexMazeService.Initialize()
    end)
end

return ComplexMazeService